// This file has been generated automatically. Don't modify it.

#ifndef __TYPES_H__
#define __TYPES_H__

#include <string>
#include <unordered_map>

template<typename T>
struct enum_converter;

template<typename T> 
std::string enum_str(T value);

template<typename T> 
T enum_value(const std::string& str);

static const std::string k_empty_str;
{% for enum_data in enums %}
// Generated from {{ enum_data.file_name }}
{% if enum_data.namespace %}namespace {{ enum_data.namespace }} { {% endif %}
enum class {{ enum_data.enum_name }} {
    {% for enum_value in enum_data.enum_values %}{{ enum_value }} = {{ loop.index0 }}{% if not loop.last %},
    {% endif %}{% endfor %}
};

template<> struct enum_converter<{{ enum_data.enum_name }}> {
    static {{ enum_data.enum_name }} enum_value(const std::string& str) {
        static const std::unordered_map<std::string, {{ enum_data.enum_name }}> enum_table {
            {% for enum_value in enum_data.enum_values %}{"{{ enum_value }}", {{ enum_data.enum_name }}::{{ enum_value }}},{% if not loop.last %}
            {% endif %}{% endfor %}
        };
        auto it = enum_table.find(str);
        if (it == enum_table.end()) {
            return {{ enum_data.enum_name }}{};
        }
        return it->second;
    }

    static const std::string& enum_str({{ enum_data.enum_name }} value) {
        static const std::unordered_map<{{ enum_data.enum_name }}, std::string> str_map {
            {% for enum_value in enum_data.enum_values %}{ {{ enum_data.enum_name }}::{{ enum_value }}, "{{ enum_value }}"},{% if not loop.last %}
            {% endif %}{% endfor %}
        };
        auto it = str_map.find(value);
        if (it == str_map.end()) {
            return k_empty_str;
        }
        return it->second;
    }
};
{% if enum_data.namespace %}} // namespace {{ enum_data.namespace }} {% endif %}

template<>
inline std::string enum_str<{% if enum_data.namespace %}{{ enum_data.namespace }}::{% endif %}{{ enum_data.enum_name }}>({% if enum_data.namespace %}{{ enum_data.namespace }}::{% endif %}{{ enum_data.enum_name }} value) {
    return enum_converter<{% if enum_data.namespace %}{{ enum_data.namespace }}::{% endif %}{{ enum_data.enum_name }}>::enum_str(value);
}

template<>
inline {% if enum_data.namespace %}{{ enum_data.namespace }}::{% endif %}{{ enum_data.enum_name }} enum_value<{% if enum_data.namespace %}{{ enum_data.namespace }}::{% endif %}{{ enum_data.enum_name }}>(const std::string& str) {
     return enum_converter<{% if enum_data.namespace %}{{ enum_data.namespace }}::{% endif %}{{ enum_data.enum_name }}>::enum_value(str);
}
{% endfor %}
#endif // __TYPES_H__